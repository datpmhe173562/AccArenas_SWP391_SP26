#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Paths
const BACKEND_DTOS_PATH = path.join(__dirname, '../../../backend/AccArenas.Api/Application/DTOs');
const OUTPUT_FILE = path.join(__dirname, '../src/types/generated-api.ts');

// C# to TypeScript type mapping
const typeMapping = {
  'Guid': 'string',
  'string': 'string',
  'int': 'number',
  'decimal': 'number',
  'bool': 'boolean',
  'DateTime': 'string', // ISO date string
  'List<string>': 'string[]',
  'IList<string>': 'string[]',
  'IEnumerable<string>': 'string[]',
};

function convertCSharpToTypeScript(csharpType) {
  const isOptional = csharpType.endsWith('?');
  const baseType = isOptional ? csharpType.slice(0, -1) : csharpType;

  let tsType;
  // Handle array types
  if (baseType.includes('List<') || baseType.includes('IList<') || baseType.includes('IEnumerable<')) {
    const innerType = baseType.match(/<(.+)>/)?.[1];
    if (innerType === 'T') {
      tsType = 'T[]';
    } else {
      const tsInnerType = typeMapping[innerType] || innerType;
      tsType = `${tsInnerType}[]`;
    }
  } else if (baseType === 'T') {
    tsType = 'T';
  } else {
    tsType = typeMapping[baseType] || baseType;
  }

  return isOptional ? `${tsType} | undefined` : tsType;
}

function parseCSharpFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const interfaces = [];

  // Regex to match class definitions and their properties, including generics
  const classRegex = /public class (\w+)(?:<(.+)>)?\s*{([^{}]*(?:{[^{}]*}[^{}]*)*?)}/g;
  let match;

  while ((match = classRegex.exec(content)) !== null) {
    const className = match[1];
    const genericParams = match[2] ? `<${match[2]}>` : '';
    const classBody = match[3];

    const properties = [];
    const propRegex = /public\s+([^=\s]+)\s+(\w+)\s*{\s*get;\s*set;\s*}(?:\s*=\s*[^;]+;)?/g;
    let propMatch;

    while ((propMatch = propRegex.exec(classBody)) !== null) {
      const propType = propMatch[1].trim();
      const propName = propMatch[2];

      // Convert property name to camelCase
      const camelCaseName = propName.charAt(0).toLowerCase() + propName.slice(1);

      properties.push({
        name: camelCaseName,
        type: convertCSharpToTypeScript(propType),
        optional: propType.includes('?')
      });
    }

    if (properties.length > 0) {
      interfaces.push({
        name: className + genericParams,
        properties
      });
    }
  }

  return interfaces;
}

function generateTypeScriptInterfaces() {
  try {
    console.log('üöÄ Generating TypeScript types from C# DTOs...');

    const allInterfaces = [];

    // Read all DTO files
    const files = fs.readdirSync(BACKEND_DTOS_PATH)
      .filter(file => file.endsWith('.cs'));

    console.log(`üìÅ Found ${files.length} DTO files`);

    for (const file of files) {
      const filePath = path.join(BACKEND_DTOS_PATH, file);
      console.log(`üìÑ Processing: ${file}`);

      const interfaces = parseCSharpFile(filePath);
      allInterfaces.push(...interfaces);
    }

    // Generate TypeScript content
    let tsContent = `// Auto-generated TypeScript types from C# DTOs
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually

`;

    for (const iface of allInterfaces) {
      tsContent += `export interface ${iface.name} {\n`;

      for (const prop of iface.properties) {
        const optional = prop.optional ? '?' : '';
        tsContent += `  ${prop.name}${optional}: ${prop.type};\n`;
      }

      tsContent += '}\n\n';
    }

    // Add common types
    tsContent += `// Common API Response Types
export interface ApiResponse<T = any> {
  success: boolean;
  message?: string;
  data?: T;
  errors?: string[];
}

export interface PaginatedResponse<T = any> {
  data: T[];
  page: number;
  pageSize: number;
  totalCount: number;
  totalPages: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

export interface ApiError {
  message: string;
  errors?: string[];
  statusCode?: number;
}
`;

    // Write to file
    fs.writeFileSync(OUTPUT_FILE, tsContent);

    console.log(`‚úÖ Successfully generated ${allInterfaces.length} TypeScript interfaces`);
    console.log(`üìÑ Output: ${OUTPUT_FILE}`);

  } catch (error) {
    console.error('‚ùå Error generating types:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  generateTypeScriptInterfaces();
}

module.exports = { generateTypeScriptInterfaces };