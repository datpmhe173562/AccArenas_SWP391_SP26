#!/usr/bin/env node

const fs = require('fs');
const path = require('path');

// Paths
const BACKEND_DTOS_PATH = path.join(__dirname, '../../../backend/AccArenas.Api/Application/DTOs');
const OUTPUT_FILE = path.join(__dirname, '../src/types/generated-api.ts');

// C# to TypeScript type mapping
const typeMapping = {
  'Guid': 'string',
  'string': 'string',
  'int': 'number',
  'decimal': 'number',
  'bool': 'boolean',
  'DateTime': 'string', // ISO date string
  'List<string>': 'string[]',
  'IList<string>': 'string[]',
  'string?': 'string | undefined',
  'int?': 'number | undefined',
  'decimal?': 'number | undefined',
  'bool?': 'boolean | undefined',
  'DateTime?': 'string | undefined'
};

function convertCSharpToTypeScript(csharpType) {
  // Handle array types
  if (csharpType.includes('List<') || csharpType.includes('IList<')) {
    const innerType = csharpType.match(/<(.+)>/)?.[1];
    const tsInnerType = typeMapping[innerType] || innerType;
    return `${tsInnerType}[]`;
  }

  // Strip trailing ? for nullable lookup
  const baseType = csharpType.replace(/\?$/, '');
  const isNullable = csharpType.endsWith('?');

  if (typeMapping[csharpType] !== undefined) return typeMapping[csharpType];
  if (typeMapping[baseType] !== undefined) {
    return isNullable ? `${typeMapping[baseType]} | undefined` : typeMapping[baseType];
  }

  // Preserve PascalCase for custom/unknown types (e.g. UserInfo stays UserInfo)
  return isNullable ? `${baseType} | undefined` : baseType;
}

function parseCSharpFile(filePath) {
  const content = fs.readFileSync(filePath, 'utf8');
  const interfaces = [];

  // Regex to match class definitions including generics like PagedResult<T>
  const classRegex = /public class (\w+(?:<\w+>)?)\s*{([^{}]*(?:{[^{}]*}[^{}]*)*)}/g;
  let match;

  while ((match = classRegex.exec(content)) !== null) {
    const className = match[1];
    const classBody = match[2];

    const properties = [];

    // Match auto-properties: public Type Name { get; set; } = ...;
    const propRegex = /public\s+([^=\s]+)\s+(\w+)\s*{\s*get;\s*(?:set;\s*)?}(?:\s*=\s*[^;]+;)?/g;
    let propMatch;

    while ((propMatch = propRegex.exec(classBody)) !== null) {
      const propType = propMatch[1].trim();
      const propName = propMatch[2];
      const camelCaseName = propName.charAt(0).toLowerCase() + propName.slice(1);

      // Handle IEnumerable<X> / List<X> / IList<X>
      const collectionMatch = propType.match(/^(?:IEnumerable|List|IList)<(\w+)>\??$/);
      if (collectionMatch) {
        const innerType = collectionMatch[1];
        const tsInnerType = typeMapping[innerType] || innerType;
        properties.push({ name: camelCaseName, type: `${tsInnerType}[]`, optional: propType.endsWith('?') });
        continue;
      }

      properties.push({
        name: camelCaseName,
        type: convertCSharpToTypeScript(propType),
        optional: propType.includes('?')
      });
    }

    // Match expression-body computed properties: public Type Name =>
    const exprPropRegex = /public\s+([^=\s]+)\s+(\w+)\s*=>/g;
    let exprMatch;
    while ((exprMatch = exprPropRegex.exec(classBody)) !== null) {
      const propType = exprMatch[1].trim();
      const propName = exprMatch[2];
      const camelCaseName = propName.charAt(0).toLowerCase() + propName.slice(1);
      properties.push({
        name: camelCaseName,
        type: convertCSharpToTypeScript(propType),
        optional: propType.includes('?')
      });
    }

    if (properties.length > 0) {
      interfaces.push({
        name: className,
        properties
      });
    }
  }

  return interfaces;
}

function generateTypeScriptInterfaces() {
  try {
    console.log('üöÄ Generating TypeScript types from C# DTOs...');

    const allInterfaces = [];

    // Read all DTO files
    const files = fs.readdirSync(BACKEND_DTOS_PATH)
      .filter(file => file.endsWith('.cs'));

    console.log(`üìÅ Found ${files.length} DTO files`);

    for (const file of files) {
      const filePath = path.join(BACKEND_DTOS_PATH, file);
      console.log(`üìÑ Processing: ${file}`);

      const interfaces = parseCSharpFile(filePath);
      allInterfaces.push(...interfaces);
    }

    // Generate TypeScript content
    let tsContent = `// Auto-generated TypeScript types from C# DTOs
// Generated on: ${new Date().toISOString()}
// Do not edit this file manually

`;

    for (const iface of allInterfaces) {
      tsContent += `export interface ${iface.name} {\n`;

      for (const prop of iface.properties) {
        const optional = prop.optional ? '?' : '';
        tsContent += `  ${prop.name}${optional}: ${prop.type};\n`;
      }

      tsContent += '}\n\n';
    }

    // Add common types
    tsContent += `// Common API Response Types
export interface ApiResponse<T = any> {
  success: boolean;
  message?: string;
  data?: T;
  errors?: string[];
}

export interface PaginatedResponse<T = any> {
  data: T[];
  page: number;
  pageSize: number;
  totalCount: number;
  totalPages: number;
  hasNext: boolean;
  hasPrevious: boolean;
}

export interface ApiError {
  message: string;
  errors?: string[];
  statusCode?: number;
}
`;

    // Write to file
    fs.writeFileSync(OUTPUT_FILE, tsContent);

    console.log(`‚úÖ Successfully generated ${allInterfaces.length} TypeScript interfaces`);
    console.log(`üìÑ Output: ${OUTPUT_FILE}`);

  } catch (error) {
    console.error('‚ùå Error generating types:', error.message);
    process.exit(1);
  }
}

// Run if called directly
if (require.main === module) {
  generateTypeScriptInterfaces();
}

module.exports = { generateTypeScriptInterfaces };